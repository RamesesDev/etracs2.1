import com.rameses.annotations.*
import java.rmi.server.UID
import com.rameses.eserver.*;
import com.rameses.common.*;

class FAASTransmittalService
{
	
	@PersistenceContext('main')
	def em
    
	@Env
	def env
	
	@Service('DateService')
	def dateSvc

    @Service('Var')
	def var

	@Service('SequenceService')
	def seqSvc
    
    @Service('LogService')
    def logSvc
	
	@Service('EntityService')
	def entitySvc
    
    def SCHEMA_NAME = 'faastransmittal'
	def TRANSMITTAL_ITEM_SCHEMA = 'faastransmittal:faastransmittal_item'
	
	def IMPORT_SCHEMA_NAME = 'faastransmittal:faastransmittalimport'
	def IMPORT_ITEM_SCHEMA_NAME = 'faastransmittal:faastransmittalimport_item'
	
    
	def SCHEMA_VERSION = '1.0'
	def OPEN_STATE = 'OPEN'
	
	def FAAS_SCHEMA_NAME = 'faas'
	def FAAS_LIST_SCHEMA_NAME = 'faas:faaslist'
	
	def LEDGER_SCHEMA = 'rptledger' 
    def LEDGER_ITEM_SCHEMA = 'rptledger:rptledgeritem' 
	
	
	
	
	def FOR_PROV_APPROVAL_STATE = 'FORPROVAPPROVAL'
	def CURRENT_STATE = 'CURRENT'
    
    
	@ProxyMethod
	public List getList( searchText, params ) {
		return getListByQuery('faastransmittal:getList', [:], params )
	}
	
	@ProxyMethod
	public List getFaasForTransmittal() {
		//default to province lgutype which should transmit 
		//curent records only
		def docstate = CURRENT_STATE 
		if( var.lgu_type?.toLowerCase() == 'municipality' ) {
			docstate = FOR_PROV_APPROVAL_STATE 
		}
		return em.sqlContext.createNamedQuery('faastransmittal:getFaasForTransmittal')
					.setParameter('docstate', docstate)
					.resultList 
	}
	
	@ProxyMethod
	public List getImportedTransmittalList( searchText, params ) {
		return getListByQuery('faastransmittal:getImportedTransmittalList', [:], params )
	}
	
	@ProxyMethod
	public def create( items ) {
		def transmittal = [
			objid    : 'TR' + new UID(),
			docstate : OPEN_STATE,
			lguid	 : var.lgu_index,
			lguname  : var.lgu_name,
			txnno    : seqSvc.getNextFormattedSeries('FAAS_TRANSMITTAL'),
			txndate  : dateSvc.serverDate,
			createdby: env.USERFORMALNAME, 
			icount   : items.size(), 
		]
		
		em.create(SCHEMA_NAME, transmittal)
		
		items.each {
			em.sqlContext.createNamedExecutor('faastransmittal:updateFaasTransmittalId')
						.setParameter('transmittalid', transmittal.objid )
						.setParameter('faasid', it )
						.execute()
						
			em.sqlContext.createNamedExecutor('faastransmittal:updateFaasListTransmittalId')
						.setParameter('transmittalid', transmittal.objid )
						.setParameter('faasid', it )
						.execute()
						
			em.create(TRANSMITTAL_ITEM_SCHEMA, [objid:transmittal.objid, faasid:it])
		}
		
		return transmittal 
	}
	
	@ProxyMethod
	public def open( objid ) {
		def transmittal = em.read(SCHEMA_NAME, [objid:objid])
		if( ! transmittal ) throw new Exception('Transmittal record does not exists or is already deleted.')
		
		transmittal.items = getTransmittalItems( objid ) 
		return transmittal
	}
	
	@ProxyMethod
	public List getTransmittalItems( objid ) {
		return em.sqlContext.createNamedQuery('faastransmittal:getTransmittalItems')
					.setParameter('transmittalid', objid)
					.resultList 
	}
	
	
	
	/*============================================================
	*
	* Export Transmittal Support
	*
	*=============================================================*/
	@ProxyMethod
	public def exportTransmittal( objid ) {
		def transmittal =  em.read( SCHEMA_NAME, [objid:objid] )
		if( ! transmittal ) throw new Exception('Transmittal record does not exists or is already deleted.')
		return transmittal
	}
	
	@ProxyMethod
	public List exportFaases( objid ) {
		def items = getTransmittalItems( objid )
		items = items.objid 
		def faases = [] 
		items.each {
			faases.add( em.read(FAAS_SCHEMA_NAME, [objid:it]) )
		}
		return faases 
	}
	
	@ProxyMethod
	public List exportFaasLists( objid ) {
		return getTransmittalItems( objid )
	}
	
	@ProxyMethod 
	public List exportLedgers( objid ) {
		return em.sqlContext.createNamedQuery('faastransmittal:getTransmittedLedgers')
					.setParameter('transmittalid', objid)
					.resultList
	}
	
	@ProxyMethod
	public List exportLedgerItems( objid ) {
		return em.sqlContext.createNamedQuery('faastransmittal:getTransmittedLedgerItems')
					.setParameter('transmittalid', objid)
					.resultList
	}
	
	@ProxyMethod
	public List exportEntities( objid ) {
		return em.sqlContext.createNamedQuery('faastransmittal:getTransmittedEntities')
					.setParameter('transmittalid', objid)
					.resultList
					.each {
						it.info = em.serializer.read( it.info )
					}
	}
	    
	
	
	/*============================================================
	*
	* Import Transmittal Support
	*
	*=============================================================*/	
	@ProxyMethod 
	public List getImportedTransmittalItems( objid ) {
		return em.sqlContext.createNamedQuery('faastransmittal:getImportedTransmittalItems')
				.setParameter('transmittalid', objid)
				.resultList 
	}
	
	@ProxyMethod
	public void checkDuplicateImportPosting( objid ) {
		def transmittalimport = em.sqlContext.createNamedQuery('faastransmittal:getFasTransmittalImportById')
									.setParameter('objid', objid)
									.singleResult
		if( transmittalimport ) throw new Exception('Transmittal has already been posted.')
	}
	
	@ProxyMethod
	public void postImportTransmittal( data ) {
		validateImport( data ) 
		
		data.entities.each { entity ->
			if( ! entityExists( entity.objid ) ) {
				em.create( entity.schemaname, entity )
			}
		}
		
		data.faases.each { faas ->
			println '='*50
			println 'faas state -> ' + faas.docstate 
			faas.fortransmittal = false
			faas.transmittalid = null 
			
			if( ! faasExists( faas.objid ) ) {
				em.create( FAAS_SCHEMA_NAME, faas )
				em.create( FAAS_LIST_SCHEMA_NAME, faas )
			}
			else {
				em.update( FAAS_SCHEMA_NAME, faas )
				em.update( FAAS_LIST_SCHEMA_NAME, faas )
			}
			if( !pinExists( faas )) {
				def pin = [pin:faas.rpu.fullpin, claimno:faas.info.claimno, docstate:faas.docstate]
				em.sqlContext.createNamedExecutor('faastransmittal:insertPin').setParameters(pin).execute()
			}
			
			em.create(IMPORT_ITEM_SCHEMA_NAME, [objid:data.transmittal.objid, faasid:faas.objid ])
		}
		
		data.ledgers.each{ ledger ->
			if( ! ledgerExists( ledger.objid ) ) {
				em.create(LEDGER_SCHEMA, ledger )
			}
			else {
				em.update(LEDGER_SCHEMA, ledger )
			}
		}
		
		data.ledgeritems.each{ item ->
			if( ledgerExists( item.parentid ) && ! ledgerItemExists(item.objid)) {
				em.create(LEDGER_ITEM_SCHEMA, item )
			}
		}
		
		def transmittalimport = [
			objid 			: data.transmittal.objid,
			docstate		: 'POSTED',
			lguid  		    : data.transmittal.lguid,
			lguname			: data.transmittal.lguname, 
			transmittalno	: data.transmittal.txnno,
			transmittaldate : data.transmittal.txndate,
			createdby		: data.transmittal.createdby,
			icount			: data.transmittal.icount,
			importedby		: env.USERFORMALNAME,
			dtimported		: dateSvc.serverDate,
		]
		em.create(IMPORT_SCHEMA_NAME, transmittalimport)
	}
	
	boolean pinExists( faas ) {
		def pin = [pin:faas.rpu.fullpin, claimno:faas.info.claimno, docstate:faas.docstate]
		pin = em.sqlContext.createNamedQuery('faastransmittal:getPin').setParameters( pin ).singleResult 
		return pin != null 
	}
	
	boolean entityExists( objid ) {
		def entity = em.sqlContext.createNamedQuery('faastransmittal:getEntityById').setParameter('objid', objid).singleResult 
		return entity != null 
	}
	
	boolean ledgerItemExists( itemid ) {
		def item = em.sqlContext.createNamedQuery('faastransmittal:getLedgerItemById').setParameter('objid', itemid).singleResult 
		return item != null 
	}
	
	boolean ledgerExists( ledgerid ) {
		def ledger = em.sqlContext.createNamedQuery('faastransmittal:getLedgerById').setParameter('objid', ledgerid).singleResult
		return ledger != null 
	}
	
	boolean faasExists( faasid ) {
		def faas = em.sqlContext.createNamedQuery('faastransmittal:getFaasById').setParameter('objid', faasid).singleResult 
		return faas != null 
	}
	
	void validateImport( data ) {
		checkDuplicateImportPosting( data.transmittal.objid )
		if( ! data.faases ) throw new Exception('At least one (1) transmitted FAAS is required.')
	}
		
		
		
		
		
	def getListByQuery( namedQuery, criteria, params ) {
        if( ! params ) params = [ _start:0, _limit:25]
		return em.sqlContext.createNamedQuery( namedQuery )
						.setParameters( criteria )
						.setFirstResult( params._start )
						.setMaxResults( params._limit )
						.resultList
	}
	
	boolean TO_BOOLEAN( value ) {
		if( value instanceof Boolean ) return value 
		return '1/y/yes/true/t'.indexOf( value.toString().toLowerCase() ) >= 0
	}
	
}

