import com.rameses.annotations.*
import java.rmi.server.UID
import com.rameses.eserver.*;
import com.rameses.common.*;
import java.util.concurrent.*
import com.rameses.uploader.HttpFileUploader
import java.io.*

class FAASService
{
	@PersistenceContext('java:system')
	def em_sys
	
	@PersistenceContext('main')
	def em
    
	@Env
	def env
	
	@Service('DateService')
	def dateSvc

    @Service('Var')
	def var

	@Service('SequenceService')
	def seqSvc
    
    @Service('LogService')
    def logSvc
    
    @Service('RPTLedgerService')
    def ledgerSvc 
    
    @Service('LandRPUService')
    def landRpuSvc
    
    @Service('BldgRPUService')
    def bldgRpuSvc
    
    @Service('MachRPUService')
    def machRpuSvc
    
    @Service('PlantTreeRPUService')
    def planttreeRpuSvc
    
    @Service('MiscRPUService')
    def miscRpuSvc
	
	@Service('MessengerService')
	def msgSvc
	
	@Service('RPTSettingService')
	def rptsettingSvc
	
	@Service('ForTransmittalService')
	def forTransmittalSvc
	
	@Service('EntityService')
	def entitySvc 

    def INTERIM_STATE = 'INTERIM'
    def FORAPPROVAL_STATE = 'FORAPPROVAL'
    def FORTAXMAP_STATE = 'FORTAXMAP'
    def FORPROVAPPROVAL_STATE = 'FORPROVAPPROVAL'
	def DISAPPROVED_STATE = 'DISAPPROVED'
	def CURRENT_STATE = 'CURRENT'
	def CANCELLED_STATE = 'CANCELLED'
	def FORREVIEW_STATE = 'FORREVIEW' 
	
	def SCHEMA_NAME = 'faas'
    def SCHEMA_VERSION = '1.0'
    def LISTSCHEMA_NAME = 'faas:faaslist'
	def DISAPPROVED_SCHEMANAME = 'faas:disapprovedfaas'
	
    def LAND_TYPE = 'land' 
    def BLDG_TYPE = 'bldg'
    def MACH_TYPE = 'mach'
    def PLANTTREE_TYPE = 'planttree'
    def MISC_TYPE = 'misc' 
	
	def UPLOAD_PATH = 'upload_path'
	
    
	@ProxyMethod
	public List getFilterList() {
		def list = em.sqlContext.createNamedQuery('faas:getFaasFilters').resultList 
		list.each{
			it.info = em.serializer.read( it.info )
		}
		return list 
	}
	
	
	@ProxyMethod
	public def getList( search, params ) {
		return getList2( search, null, params ) 
	}
	
	@ProxyMethod
	public def getListByFilter( search, filter, params ) {
		if( ! filter ) {
			return getList( null, null) 
		}
		
		def qry = em.sqlContext.createNamedQuery('faas:findByFilter')
		
		def whereclause = ['1=1']
		
		if( filter.info.docstate ) {
			whereclause << ' docstate = $P{docstate} '
		}
		if( filter.info.barangay ) {
			whereclause << ' barangayid = $P{barangayid} '
		}
		if( filter.info.classification ) {
			whereclause << ' classid = $P{classid} '
		}
		if( filter.info.rputype ) {
			whereclause << ' rputype = $P{rputype} '
		}
		if( filter.info.owner ) {
			whereclause << ' taxpayerid = $P{taxpayerid} '
		}

		def filtervalue = [
			docstate 	: ( filter.info.docstate ? filter.info.docstate 		: null ),
			barangayid 	: ( filter.info.barangay ? filter.info.barangay.objid : null ),
			classid 	: ( filter.info.classification ? filter.info.classification.objid : null ),
			rputype 	: ( filter.info.rputype ? filter.info.rputype : null ),
			taxpayerid 	: ( filter.info.owner  ? filter.info.owner.objid : null ),
		]
		
		return qry.setVars([whereclause:whereclause.join(' and ')])
					.setParameters( filtervalue )
					.setFirstResult( params._start )
					.setMaxResults( params._limit )
					.resultList 
	}
	
	@ProxyMethod
	public def getList2( search, docstate, params ) {
		def result = null
        def criteria = buildSearchCriteria( search, docstate )
		if( ! search ) return getListByQuery('faas:findByState', criteria, params)
		if( (result = getListByQuery('faas:findByTdNo', criteria, params)) ) return result
		if( (result = getListByQuery('faas:findByTaxpayerName', criteria, params)) ) return result
		if( (result = getListByQuery('faas:findByTaxpayerId', criteria, params)) ) return result
		if( (result = getListByQuery('faas:findByPin', criteria, params)) ) return result
		if( (result = getListByQuery('faas:findByBarangay', criteria, params)) ) return result
		if( (result = getListByQuery('faas:findByCadastralLotNo', criteria, params)) ) return result
		if( (result = getListByQuery('faas:findBySurveyNo', criteria, params)) ) return result
		if( (result = getListByQuery('faas:findByBlockNo', criteria, params)) ) return result
		return result
	}
	
	@ProxyMethod
	public def getLookupList( searchText, params ) {
		def result;
		
		if( !searchText ) return getListByQuery('faas:getLookupList', [:], params )
		if((result = getListByQuery('faas:getLookupByTdNo', [tdno:searchText], params))) return result
		
		return result
	}
	
	@ProxyMethod
	public List getClearedFaasList( searchText, taxpayerid, params) {
		def criteria = buildSearchCriteria( searchText, null )
		criteria.taxpayerid = ( taxpayerid  ? taxpayerid : '%' )
		if( ! searchText ) return getListByQuery('faas:findClearedByState', criteria, params, 'f.objid')
		def result = []
		if( (result = getListByQuery('faas:findClearedByTdNo', criteria, params, 'f.objid')) ) return result
		if( (result = getListByQuery('faas:findClearedByPin', criteria, params, 'f.objid')) ) return result
		if( (result = getListByQuery('faas:findClearedByTaxpayername', criteria, params, 'f.objid')) ) return result
		return result
	}
	
	@ProxyMethod
	public List getRyList( rputype ) {
		if( !rputype || 'land'.equals( rputype ) ) {
			return em.sqlContext.createNamedQuery('faas:getLandRYSetting').resultList 
		}
		else if( 'bldg'.equals( rputype ) ) {
			return em.sqlContext.createNamedQuery('faas:getBldgRYSetting').resultList 
		}
		else if( 'mach'.equals( rputype ) ) {
			return em.sqlContext.createNamedQuery('faas:getMachRYSetting').resultList 
		}
		else if( 'planttree'.equals( rputype ) ) {
			return em.sqlContext.createNamedQuery('faas:getPlantTreeRYSetting').resultList 
		}
		else if( 'misc'.equals( rputype ) ) {
			return em.sqlContext.createNamedQuery('faas:getMiscRYSetting').resultList 
		}
		return []
	}
	
	@ProxyMethod
	public List getCityMunicipalityList() {
		return em.sqlContext.createNamedQuery('faas:getCityMunicipalityList').resultList 
	}
	
	def buildSearchCriteria( search, docstate ) {
		return [
            tdno : search,
            taxpayername : search+'%',
            pin : search,
            barangay : search,
            cadastrallotno : search,
            surveyno : search,
            blockno  : search,
			docstate : ( docstate ? docstate : '%' ),
        ]
	}
    
    @ProxyMethod
    public Map createFaas( ) {
        def ry = getCurrentRY()
        return [
            objid         : 'F' + new UID(),
            schemaname    : SCHEMA_NAME, 
            schemaversion : SCHEMA_VERSION,
            docstate      : INTERIM_STATE,
            transmitted   : false,
			info          : [   datacapture : true, 
                                prevmv      : 0.0, 
                                prevav      : 0.0, 
                                effectivityqtr  : 1, 
                                memoranda       : 'REVISED PURSUANT TO R.A. 7160', 
                                autonumber      : TO_BOOLEAN( var.td_autonumber ),
                                backtaxyrs      : 0, 
                                claimno			: '-',
								annotated		: false, 
                            ],
            rp            : [lgutype: var.lgu_type?.toLowerCase(), attributes:[], autonumber:var.pin_autonumber, pintype:var.pin_type?.toLowerCase()],
            rpu           : [ry:ry, classid:'RES', classcode:'RES', classname:'RESIDENTIAL',suffix:0,info:[:], taxable:true, totalareasqm:0.0, totalareaha:0.0],
            previousfaases: [],
            lgutype       : var.lgu_type,
			lguid		  : var.lgu_index,
			lguname       : var.lgu_name,
        ]
    }
    
    @ProxyMethod
    public Map validateCreate( faas ) {
        resolveRpuType( faas  )
        buildPinInfo( faas )
        validateRpu( faas )
        initFaasInfo( faas )
        return faas 
    }
    
    @ProxyMethod
    public Map create( faas ) {
        checkDuplicateTdNo( faas.objid, faas.info.tdno )
        validateRpu( faas )
        em.validate( faas.schemaname, faas )
        em.validate( LISTSCHEMA_NAME, faas )
		faas.txntimestamp = dateSvc.buildCustomTimeStamp( faas.info.issuedate ) 
        em.create( faas.schemaname, faas )
        em.create( LISTSCHEMA_NAME, faas )
        createPIN( faas ) 
		carryoverAnnotations( faas )
        insertTxnReference( faas )
        logSvc.log('CREATE','Faas', faas.objid)
        return faas 
    }
	
	void carryoverAnnotations( faas ) {
		if( faas.info.annotated == false ) return 
		//copy annotations of previous faas 
		faas.previousfaases.each{ prev ->
			def activeAnnotationList = getActiveAnnotationList( prev.faasid )
			activeAnnotationList.each{ newAnnotation ->
				newAnnotation.objid 	= 'A' + new UID()
				newAnnotation.faasid 	= faas.objid 
				newAnnotation.tdno		= faas.info.tdno 
				em.create( newAnnotation.schemaname, newAnnotation )
			}
		}
	}
	
	@ProxyMethod
	public def getActiveAnnotationList( faasid ) {
		return em.sqlContext.createNamedQuery('faas:getActiveAnnotations')
						.setParameter( 'faasid', faasid )
						.resultList 
	}
	
	@ProxyMethod
	public def getActiveAnnotationTexts( faasid ) {
		return em.sqlContext.createNamedQuery('faas:getActiveAnnotationTexts')
						.setParameter( 'faasid', faasid )
						.resultList 
	}
    
    @ProxyMethod
    public Map update( faas ) {
        checkDuplicateTdNo( faas.objid, faas.info.tdno )
        em.validate( faas.schemaname, faas )
        em.validate( LISTSCHEMA_NAME, faas )
        
		faas.txntimestamp = dateSvc.buildCustomTimeStamp( faas.info.issuedate ) 
		
        if( faas.docstate == INTERIM_STATE ) {
            em.update( faas.schemaname, faas )
        }
        else {
            em.update( faas.schemaname, faas );
			/*
            em.update( faas.schemaname, faas, { diff ->
                logSvc.logB('UPDATE', 'FAAS', faas.objid, '', diff )
            } as UpdateChangeHandler )
			*/
        }
        em.update( LISTSCHEMA_NAME, faas )
        return faas 
    }    
    
    @ProxyMethod
    public Map open( faasid ) {
        def faas = em.read( SCHEMA_NAME, [objid:faasid] )
        if( !faas ) throw new Exception('FAAS does not exists.')
        faas.info.datacapture 	= TO_BOOLEAN( faas.info.datacapture )
		faas.info.annotated 	= ( faas.info.annotated ? TO_BOOLEAN( faas.info.annotated ) : false )
        faas.info.autonumber 	= TO_BOOLEAN( faas.info.autonumber )
        faas.rpu.taxable 		= TO_BOOLEAN( faas.rpu.taxable )
		
		//populate landfaasid : fix for migrated data 
		if( faas.rpu.rputype != 'land' ) {
			if( ! faas.info.landfaasid ) 
				faas.info.landfaasid = faas.rpu.info.landfaasid 
			if( ! faas.info.landfaastaxpayerid ) 
				faas.info.landfaastaxpayerid = faas.rpu.info.landfaastaxpayerid
		}
		
        initOpenRpuInfo( faas.rpu )
		
		//the statements below are for those migrated data with null initialization values
		if( faas.info.txntype == 'MC' && (!faas.info.claimno || faas.info.claimno.trim() == '-') ) {
			def result = em.sqlContext.createQuery('select claimno from faaslist where objid=?').setParameter(1, faas.objid).singleResult
			faas.info.claimno = result.claimno
		}
		
		//some migrated data's effectivityqtr is string
		if( faas.info.effectivityqtr instanceof String ) {
			try {
				faas.info.effectivityqtr = new Integer(faas.info.effectivityqtr);
			}
			catch(e) {}
		}
		
		return faas 
    }
    
    @ProxyMethod
    public Map getFaasInfo( faasid ){
        def faasinfo = em.read(LISTSCHEMA_NAME, [objid:faasid])
        if( ! faasinfo ) throw new Exception('Cannot open FAAS with ID No. ' + faasid )
        faasinfo.datacapture = TO_BOOLEAN( faasinfo.datacapture )
        return faasinfo 
    }
    
    @ProxyMethod
    public Map submit( faasid ) {
		def faasinfo = getFaasInfo( faasid )
		validateSubmit( faasinfo )
		def faas = open( faasinfo.objid )
		updateFaasState( faas, FORAPPROVAL_STATE )
		logSvc.log('SUBMIT','FAAS', faasid)
		return faas 
    }
	
	@ProxyMethod 
	public def submitRemoteApproval( faasid ) {
		def faas = open( faasid )
		if( faas.docstate == FORAPPROVAL_STATE ) throw new Exception('FAAS has already been submitted for approval.')
        if( faas.docstate == CURRENT_STATE ) throw new Exception('FAAS is already current.')
        if( faas.docstate == DISAPPROVED_STATE ) throw new Exception('FAAS has already been disapproved.')
        if( faas.docstate == CANCELLED_STATE ) throw new Exception('FAAS has already been cancelled.')
		
		faas.docstate = FORAPPROVAL_STATE
		if( ! faas.info.datacapture   ) {
			def currDate            = dateSvc.getServerDate()
			faas.info.reviewedby    = env.USERNAME
			faas.info.reviewedbytitle = env.JOBTITLE
			faas.info.dtreviewed    = currDate
			faas.message            = null
		}
		
		em.update( SCHEMA_NAME, faas )
        updateFaasListState( faasid, FORAPPROVAL_STATE )
		return faas
	}
	
	@ProxyMethod 
    public Map submitToProvince( faasid ) {
        def faasinfo = getFaasInfo( faasid )
        validateSubmitToProvince( faasinfo )
        def faas = open( faasinfo.objid )
		insertForTransmittal( faas )
		updateFaasState( faas, FORPROVAPPROVAL_STATE )
        updateMessage(faas, null )
        updateAttachmentStates( faas, 'FORTRANSMITTAL' )
        sendToOutbox( faas )
        logSvc.log('SUBMIT_TO_PROVINCE','FAAS', faasid)
        return faas 
    }
    
    @ProxyMethod
    public Map approve( faasid ) {
		def faasinfo = getFaasInfo( faasid )
        validateApprove( faasinfo )
        def faas = open( faasinfo.objid )
        updateAutonumberTdNo( faas  )
        invokeCommonApproveActions( faas )
        logSvc.log('APPROVE','FAAS', faas.objid)
		return faas 
    }
	
	
	@ProxyMethod
	public def approveRemote( faasid ) { 
		def faas = open( faasid )
        if( faas.docstate == FORPROVAPPROVAL_STATE ) throw new Exception('FAAS has not yet beeen reviewed.')
        if( faas.docstate == CURRENT_STATE ) throw new Exception('FAAS is already current.')
        if( faas.docstate == DISAPPROVED_STATE ) throw new Exception('FAAS has already been disapproved.')
        if( faas.docstate == CANCELLED_STATE ) throw new Exception('FAAS has already been cancelled.')
        
		checkDuplicatePin( faas.info.txntype, faas.info.datacapture, faas.rpu.fullpin, faas.info.claimno  )
		
		if( assignNewTdNo( faas ) ) {
			def newtdno = getNextAutonumberTdNo( faas )
			checkDuplicateTdNo( faas.objid, newtdno )
            faas.info.tdno = newtdno 
		}
		
		faas.docstate  = CURRENT_STATE 
		if (faas.info.datacapture == false ) {
			def currDate            = dateSvc.getServerDate()
			faas.info.issuedate     = dateSvc.format('yyyy-MM-dd', currDate)
			faas.info.dtapproved    = currDate
			faas.approvedby         = var.provincial_assessor_name
			faas.approvedbytitle    = var.provincial_assessor_title
			faas.sys_dtapproved     = currDate
			faas.message            = null
		}
		
        em.update( faas.schemaname, faas )
        updateFaasListState( faasid, CURRENT_STATE )
        em.sqlContext.createNamedExecutor('faas:updateListTdNo').setParameters([tdno:faas.info.tdno, objid:faas.objid]).execute()
        
		createPIN( faas ) 
		// createEntity( faas )
		
		updateImprovementLandReference( faas ) 
		approveCarryOverAnnotations( faas )
		insertRPUItems( faas )
		cancelPreviousFaas( faas )
		deleteTxnReference( faas )
		
		//default value for post_municipal_rptledger_to_province must be false 
		if( TO_BOOLEAN( var.post_municipal_rptledger_to_province ) == true ) {
			ledgerSvc.post( faas.objid )
		}
		
        sendRemoteMessage( faas, 'faas.approve', [
			faasid		: faas.objid,
			docstate	: faas.docstate,
			approvedby	: faas.info.approvedby,
			approvedbytitle : faas.info.approvedbytitle,
			dtapproved		: faas.info.dtapproved,
			tdno			: faas.info.tdno,
			pin				: faas.rp.pin,
			fullpin			: faas.rpu.fullpin, 
		])
		return faas 
	}
	
	@ProxyMethod
    public Map disapprove( faasid ) {
        def faasinfo = getFaasInfo( faasid )
        if( faasinfo.docstate == INTERIM_STATE) throw new Exception('FAAS is still interim.')
        if( faasinfo.docstate == CURRENT_STATE) throw new Exception('FAAS is already current.')
        if( faasinfo.docstate == CANCELLED_STATE) throw new Exception('FAAS has already been cancelled.')
        def faas = open( faasinfo.objid )
        updateFaasState( faas, INTERIM_STATE )
        moveOutboxMessageToProcessed( faasid )
        return faas 
    }
    
    @ProxyMethod
    public Map approveByProvince( faasid ) {
		def faasinfo = getFaasInfo( faasid )
        validateProvinceApproval( faasinfo )
        def faas = open( faasinfo.objid )
		if( var.lgu_type?.toLowerCase() == 'province' ) {
			insertForTransmittal( faas )
		}
		updateAutonumberTdNo( faas )
		assignNextPin( faas ) 
        invokeCommonApproveActions( faas )
        logSvc.log('APPROVEBYPROVINCE','FAAS', faas.objid)
		return faas 
    }
	
    @ProxyMethod
    public Map disapproveByProvince( faasid ) {
        def faasinfo = getFaasInfo( faasid )
        if( faasinfo.docstate == INTERIM_STATE) throw new Exception('FAAS is still interim.')
        if( faasinfo.docstate == CURRENT_STATE) throw new Exception('FAAS is already current.')
        if( faasinfo.docstate == CANCELLED_STATE) throw new Exception('FAAS has already been cancelled.')
        def faas = open( faasinfo.objid )
        updateFaasState( faas, INTERIM_STATE )
        moveOutboxMessageToProcessed( faasid )
        return faas 
    }
    
    @ProxyMethod
    public void onlineApprove( faasid, approvaldata  ) {
        def faas = open( faasid )
		if( faas.docstate == CURRENT_STATE || faas.docstate == CANCELLED_STATE)  {
            //the faas is already approve
            //this happens if the approval was done manually
            //so just return the faas 
            return 
        }
        faas.info.tdno          = approvaldata.tdno
        faas.info.dtapproved    = approvaldata.dtapproved 
        faas.message            = null 
        //update pin for land type 
        if( faas.info.datacapture == false && faas.rpu.rputype == LAND_TYPE) {
            deletePin( [fullpin: faas.rpu.fullpin] )
            faas.rp.pin         = approvaldata.pin 
            faas.rpu.fullpin    = approvaldata.fullpin 
            createOnlinePIN( faas ) 
        }
        em.update( faas.schemaname, faas )
        em.update(LISTSCHEMA_NAME, faas )
        invokeCommonApproveActions( faas )
    }
	
	@ProxyMethod
	public def disapproveRemote( faasid, remarks )  {
		def faas = open( faasid )
		if( faas.docstate == DISAPPROVED_STATE ) throw new Exception('FAAS has already been disapproved.')
        if( faas.docstate == CANCELLED_STATE ) throw new Exception('FAAS has already been cancelled.')
		
		// copy to disapproved faas 
        def currDate            = dateSvc.getServerDate()
		faas.docstate           = DISAPPROVED_STATE
		faas.message            = remarks
		if( faas.info.datacapture == false ) {
			faas.sys_dtapproved     = null
			faas.info.approvedby    = null 
			faas.info.approvedbytitle = null 
			faas.info.dtapproved      = null 
		}
        
        def dfaas = [:]
        dfaas.putAll( faas )
        dfaas.objid  = 'DF' + new UID()
        dfaas.faasid = faas.objid 
		em.create(DISAPPROVED_SCHEMANAME, dfaas)
		em.sqlContext.createNamedExecutor('faas:deleteFaasAttachments').setParameter('faasid', faas.objid).execute()
        em.delete( LISTSCHEMA_NAME, faas)
		em.delete(faas.schemaname, faas)
        
		sendRemoteMessage( faas, 'faas.disapprove', [
			faasid		: faas.objid,
			tdno		: faas.info.tdno,
			pin			: faas.rp.pin,
			fullpin		: faas.rpu.fullpin, 
			message		: faas.message 	
		])
		return faas
	}
    
    @ProxyMethod
    public void onlineDisapprove( faasid, disapprovaldata ) {
        def faas = open( faasid  )
        if( faas.docstate == CURRENT_STATE || faas.docstate == CANCELLED_STATE){
            //the faas has already been approved or superseded
            //do not alter the state, just a message 
            return 
        }  
        faas.message = disapprovaldata.message 
        updateMessage( faas, faas.message )
        updateFaasState( faas, FORAPPROVAL_STATE )
    }
    
    @ProxyMethod
    public Map approveSubdivisionFaas( faasid ) {
        def faasinfo = getFaasInfo( faasid )
        validateApprove( faasinfo )
        def faas = open( faasinfo.objid )
		updateAutonumberTdNo( faas  )
        validateRPUInfo( faas )
        updateFaasState( faas, CURRENT_STATE )
		insertRPUItems( faas )
        cancelPreviousFaas( faas )
        deleteTxnReference( faas )
        ledgerSvc.postSubdivisionFaas( faas.objid )
        logSvc.log('APPROVE','FAAS', faas.objid)
        return faas 
    }
    
    @ProxyMethod
    public Map approveConsolidatedFaas( faasid ) {
        def faasinfo = getFaasInfo( faasid )
        validateApprove( faasinfo )
        def faas = open( faasinfo.objid )
        assignNextPin( faas )
        updateAutonumberTdNo( faas  )
        validateRPUInfo( faas )
        updateFaasState( faas, CURRENT_STATE )
		insertRPUItems( faas )
        cancelPreviousFaas( faas )
		deleteTxnReference( faas )
        ledgerSvc.postConsolidatedFaas( faas.objid )
        logSvc.log('APPROVE','FAAS', faas.objid)
        return faas 
    }
    
    void invokeCommonApproveActions( faas ) {
        validateRPUInfo( faas )
		updateFaasState( faas, CURRENT_STATE )
		updateImprovementLandReference( faas ) 
		approveCarryOverAnnotations( faas )
		insertRPUItems( faas )
		cancelPreviousFaas( faas )
		deleteTxnReference( faas )
		ledgerSvc.post( faas.objid )
		moveOutboxMessageToProcessed( faas.objid )
		logSvc.log('APPROVE','FAAS', faas.objid)
    }
	
	@ProxyMethod
	public void insertRPUItems( faas ) {
		if( faas.rpu.rputype == 'land' )
			landRpuSvc.insertRPUItems( faas )
	}
    
	@ProxyMethod 
	public void approveCarryOverAnnotations( faas ){
		// approve carryover annotations 
		em.sqlContext.createNamedExecutor('faas:updateFAASAnnotationInfo')
				.setParameters([
					faasid:faas.objid, tdno:faas.info.tdno, docstate:'APPROVED'
				])
				.execute() 
	
		//cancel previous annotations 
		faas.previousfaases.each{ prev -> 
			em.sqlContext.createNamedExecutor('faas:updateFAASAnnotationState')
				.setParameters([faasid:prev.faasid, docstate:'CANCELLED'])
				.execute() 
		}
	}
	
	void updateFAASAnnotationState( faasid, docstate ) {
		
	}
	
	
    @ProxyMethod
    public void delete( faasid ) {
        def faasinfo = getFaasInfo( faasid )
        
        //validate delete 
        if( faasinfo.docstate == FORPROVAPPROVAL_STATE ) throw new Exception('FAAS has already been submitted for province approval.' )
		if( faasinfo.docstate == CURRENT_STATE ) throw new Exception('FAAS is already current.' )
		if( faasinfo.docstate == CANCELLED_STATE ) throw new Exception('FAAS has already been cancelled.' )
		
        checkFaasTxnReference( faasid )
		deleteTxnReference( [objid:faasid ] )
        
        //delete record
        if( faasinfo.datacapture ) {
            deletePin( faasinfo )
        }
		deleteFAASAnnotations( faasid )
        em.delete(LISTSCHEMA_NAME, [objid:faasid] )
        em.delete(SCHEMA_NAME, [objid:faasid ] )
    }
    
	void deleteFAASAnnotations( faasid ) {
		em.sqlContext.createNamedExecutor('faas:deleteFAASAnnotations').setParameter('faasid', faasid).execute()
	}
	
    @ProxyMethod
    public def getNextParcelNo( barangay, section ) {
        def key = barangay.pin + '-' + buildSectionNo( section )
        return seqSvc.getCurrentSeries( key )
    }
    
    @ProxyMethod
    public def buildSectionNo( section )  {
		def sectionLen = Integer.parseInt( var.pin_section_length )
		return section.toString().padLeft(sectionLen, '0')
	}
	
	@ProxyMethod
    public def buildParcelNo( newSeries ) {
		def parcelLen = Integer.parseInt( var.pin_parcel_length )
		return newSeries.toString().padLeft( parcelLen,'0')
	}
    
    @ProxyMethod
    public def resolveTxnType( txntype ) {
        def type = getTxnTypes().find{ it.txntype == txntype }
        if( ! type ) throw new Exception('TxnType ' + txntype + ' is not defined in TxnTypes.')
        return type 
    }
    
    @ProxyMethod
    public void assignNextPin( faas  ) {
        def autonumber = TO_BOOLEAN( faas.rp.autonumber )
		def datacapture = TO_BOOLEAN (faas.info.datacapture )
		if( ! autonumber ) return 
		if( faas.rp.pin == '-' ) return 
		if( faas.rpu.rputype != LAND_TYPE ) return 
		if( datacapture ) return 
		if( 'MC,ND,SD,CS'.indexOf( faas.info.txntype ) < 0 ) return 
		
        def key =   faas.rp.provcityindex + '-' + 
                    faas.rp.munidistrictindex + '-' + 
                    faas.rp.barangayindex + '-' + faas.rp.section 
					
        def nextparcel      = seqSvc.getNextSeries( key )
        faas.rp.pin         = key + '-' + buildParcelNo( nextparcel )
        faas.rpu.fullpin    = faas.rp.pin 
        checkDuplicatePin( faas.info.txntype, faas.info.datacapture, faas.rpu.fullpin, faas.info.claimno  )
		createPIN( faas ) 
		em.update( faas.schemaname, faas )
		em.update( LISTSCHEMA_NAME, faas )
    }
    
    @ProxyMethod
	public def assignPin( faas, key, section, newSeries, oldSeries ) {
		if( faas.rpu.rputype != 'land') throw new Exception("Only Land RPU could be assigned a new PIN.")
		if( ! faasExists( faas.objid ) ) throw new Exception("FAAS not found.")
		
		validateParcelSeries( key, newSeries, oldSeries ) 
		def sectionNo       = buildSectionNo( section )
		def parcelNo        = buildParcelNo( newSeries )
		def pin             = key + '-' + parcelNo
        faas.rp.pin         = pin 
        faas.rpu.fullpin    = pin 
		checkDuplicatePin( faas.info.txntype, faas.info.datacapture, faas.rpu.fullpin, faas.info.claimno  )
		seqService.updateNextSeries( key, newSeries + 1)
		
		/* update faas pin related info */
		faas.rp.section  = sectionNo
		faas.rp.parcel   = parcelNo
		em.update( faas.schemaname, faas )
        def params = [objid:faas.objid, fullpin:faas.rpu.fullpin, pin:faas.rp.pin ]
		em.sqlContext.createNamedExecutor('faas:updateFaasListPin').setParameters(params ).execute()
		return faas
	}
    
    private void validateParcelSeries( key, newSeries, oldSeries) {
		def seq = em_sys.sqlContext.createNamedQuery("sequence:getCurrentSeries").setParameter("objid",key).singleResult
		if( seq && oldSeries != seq.currentSeries ) throw new Exception("Current Series has been modified. Please try again.")
		if( seq && seq.currentSeries > newSeries) throw new Exception("New Series $newSeries must be greater than or equal to $seq.currentSeries")
	}
    
    /*-----------------------------------------------------------------------
    ** Transaction Support Methods
    -----------------------------------------------------------------------*/
    @ProxyMethod
    public Map createNewDiscovery() {
        def faas            = createFaas() 
        faas.info.txntype   = 'ND'
        faas.info.txn       = resolveTxnType( faas.info.txntype )
        faas.info.datacapture = false 
        return faas 
    }
	
    @ProxyMethod
	public Map initTransaction( txntype, prevtdno, autonumber, claimno) {
		return initTransaction2( txntype, prevtdno, autonumber, claimno, null )
	}
	
	@ProxyMethod
    public Map initTransaction2( txntype, prevtdno, autonumber, claimno, newrysetting ) {
		autonumber = TO_BOOLEAN( var.td_autonumber )
		def faas = em.sqlContext.createNamedQuery('faas:getInfoByTdno').setParameter('tdno', prevtdno).singleResult
        if( ! faas ) throw new Exception('FAAS ' + prevtdno + ' does not exists.')
        if( faas.docstate == CANCELLED_STATE ) throw new Exception('FAAS ' +  prevtdno + ' has already been cancelled.')
        if( faas.docstate != CURRENT_STATE ) throw new Exception('FAAS ' +  prevtdno + ' is not current.')
        
		checkFaasTxnReference( faas.objid )
		checkDuplicatePin( txntype, false, faas.fullpin, claimno  )
        faas = open( faas.objid )
        faas.info.claimno = claimno 
        if( txntype == 'TR' ) {
			return initTransfer( faas, txntype, prevtdno, autonumber )
		}
		else if( txntype == 'TRE' || txntype == 'TRC' ) {
			return initTransfer( faas, txntype, prevtdno, autonumber )
		}
		else if( txntype == 'GR' ) {
			return initGeneralRevision( faas, txntype, prevtdno, autonumber, newrysetting )
		}
        else if( 'CC,RE,CE,CT'.indexOf( txntype ) >= 0 ) {
			return initReassessment( faas, txntype, prevtdno, autonumber )
		}
		else if( 'CD'.indexOf( txntype ) >= 0 ) {
			if( faas.rputype == LAND_TYPE ) throw new Exception('Cannot depreciate a Land property.')
			return initReassessment( faas, txntype, prevtdno, autonumber )
		}
		else if( 'MC'.indexOf( txntype ) >= 0 ) {
			return initMultipleClaim( faas, txntype, prevtdno, autonumber )
		}
		else {
            throw new Exception('TxnType ' + txntype + ' not yet supported.')
        }
    }
    
    
    @ProxyMethod
    public void checkDuplicateTdNo( faasid, tdno ) {
        if( ! tdno ) return 
        def data = em.sqlContext.createNamedQuery('faas:checkDuplicateTdNo').setParameters([objid:faasid, tdno:tdno]).singleResult
        if( data ) throw new Exception('TD No. ' + tdno + ' is already existing.')
    }
    
    @ProxyMethod
    public List getLandImprovementIds( landfaasid) {
        return em.sqlContext.createNamedQuery('faas:getLandImprovementIds').setParameter('landfaasid', landfaasid ).resultList 
    }
    
    
    @ProxyMethod
    public List getTxnTypes() {
        return [
            [txntype:'DC', caption:'Data Capture'],
            [txntype:'GR', caption:'General Revision'],
            [txntype:'ND', caption:'New Discovery'],
            [txntype:'TR', caption:'Transfer of Ownership'],
			[txntype:'TRE', caption:'Transfer with Reassessment'],
			[txntype:'TRC', caption:'Transfer with Correction'],
            [txntype:'SD', caption:'Subdivision'],
            [txntype:'CS', caption:'Consolidation'],
            [txntype:'CC', caption:'Change Classification'],
            [txntype:'CT', caption:'Change Taxability'],
			[txntype:'CD', caption:'Change Depreciation'],
            [txntype:'CE', caption:'Correction'],
            [txntype:'CTD', caption:'Cancellation'],
            [txntype:'RE', caption:'Reassessment'],
            [txntype:'MC', caption:'Multiple Claim'],
        ]
        //return ['DC','GR','RL','ND','IL','LI','TR','MU','SD','CS','PR','PC','CC','AR','CT','CD','CE','BI','CTD','RE','MC','CP']
    }
	
	@ProxyMethod
	public List getTitleTypeList() {
		return ['OCT','TCT','CLOA','EP', 'KOT', 'CLT', 'T', 'P']
	}
     
	@ProxyMethod
	public List getMunicipalities() {
		return em.sqlContext.createNamedQuery('faas:getMunicipalities').resultList 
	}
	
    @ProxyMethod
    public List getBarangays() {
        return em.sqlContext.createNamedQuery('faas:getBarangays').resultList 
    }
	
	@ProxyMethod
	public List getBarangaysByLguType( parentid, lgutype) {
		lgutype = lgutype?.toLowerCase()
		if( 'municipality' == lgutype  ) {
			return getBarangayListByParentId( parentid )
		}
		else if( 'city' == lgutype ) {
			return em.sqlContext.createNamedQuery('faas:getBarangays').resultList 
		}
		return []
	}
	
	@ProxyMethod
    public List getBarangayListByParentId( parentid ) {
		if( ! parentid ) return []
        return em.sqlContext.createNamedQuery('faas:getBarangayListByParentId')
					.setParameter('parentid', parentid)
					.resultList 
    }
    
    @ProxyMethod
    public void checkLedgerBalance( faas ) {
		checkLedgerBalanceByDate( faas, dateSvc.serverDate )
    }
	
	@ProxyMethod
	public void checkLedgerBalanceByDate( faas, refdate ) {
		checkLedgerBalanceByTxnType(faas.txntype, faas, refdate )
	}
	
	@ProxyMethod
    public void checkLedgerBalanceByTxnType( txntype, faas, refdate ) {
		if( txntype == 'MC' ) return 
		
		//if province then check only if a ledger exists
		//in case the ledger does not exists then bypass checking 
		def ledger = em.sqlContext.createNamedQuery('faas:getLedgerInfo').setParameter('objid', faas.ledgerid ).singleResult
        if( !ledger && var.lgu_type?.toLowerCase() != 'province' ) throw new Exception('Cannot open Ledger for FAAS ' + faas.tdno + '.')
        
		if( ledger ) {
			//check clearance against FAAS issuedate 
			def parseddate = dateSvc.parseDate( refdate, null )
			if( ledger.docstate == 'PENDING' ) throw new Exception('Ledger is not yet approved.\nLet LandTax approve the ledger before processing the transaction.')
			if( ledger.docstate == 'CANCELLED') throw new Exception('Ledger has already been cancelled.')
			if( TO_BOOLEAN( ledger.taxable ) == false ) return 
			
			if( isTxnAllowedWithBalance( txntype ) ) return
			
			def errmsg = 'Ledger is not fully paid.'
			if( ledger.assessedvalue > 0.0 && ledger.lastyearpaid < parseddate.year ) throw new Exception( errmsg )
			if( ledger.assessedvalue > 0.0 && ledger.lastqtrpaid < 4 ) throw new Exception( errmsg )
		}
    }
    
	@ProxyMethod
	public boolean isTxnAllowedWithBalance( txntype ) {
		def rptsetting = rptsettingSvc.open()
		if( !rptsetting ) {}
		else if( txntype.matches(/TR|TRE|TRC/) && rptsetting.allowtransferwithbalance )  return true
		else if( txntype == 'CE' && rptsetting.allowcorrectionwithbalance )          return true
		else if( txntype == 'CT' && rptsetting.allowchangetaxabilitywithbalance )    return true
		else if( txntype == 'SD' && rptsetting.allowsubdivisionwithbalance )         return true
		else if( txntype == 'CS' && rptsetting.allowconsolidationwithbalance )       return true
		else if( txntype == 'CC' && rptsetting.allowreclasswithbalance )             return true
		else if( txntype == 'RE' && rptsetting.allowreassessmentwithbalance )        return true
		else if( txntype == 'CD' && rptsetting.allowchangedepreciationwithbalance )  return true
		
		return false;
	}
    
    @ProxyMethod
    public void initFaasInfo( faas ) {
        faas.info.txntype = faas.info.txn.txntype 
        String rputype = faas.rpu.rputype 
        if( rputype != LAND_TYPE ) {
            updateLandRPInfo( faas )
        }
        if( rputype == LAND_TYPE) landRpuSvc.initLandRpu( faas.rpu )
        else if( rputype == BLDG_TYPE) bldgRpuSvc.initBldgRpu( faas )
        else if( rputype == MACH_TYPE) machRpuSvc.initMachRpu( faas )
        else if( rputype == PLANTTREE_TYPE) planttreeRpuSvc.initPlantTreeRpu( faas )
        else if( rputype == MISC_TYPE) miscRpuSvc.initMiscRpu( faas )
        else throw new Exception('Invalid RPU Type ' + rputype + '.')
    }
    
    
    @ProxyMethod
    public void checkSuffix( rputype, suffix ) {
        if( rputype == LAND_TYPE && suffix != 0  ) {
            throw new Exception('Suffix must be zero for land property.')
        }
        else if( rputype == BLDG_TYPE && (suffix < 1001 || suffix > 1999 )) {
            throw new Exception('Suffix must be between 1001 and 1999 for building property.')
        }
        else if( rputype == MACH_TYPE && (suffix < 2001 || suffix > 2999 )) {
            throw new Exception('Suffix must be between 2001 and 2999 for machine property.')
        }
        else if( rputype == PLANTTREE_TYPE && (suffix < 3001 || suffix > 6999 )) {
            throw new Exception('Suffix must be betwwen 3001 and 6999 for plant/tree property.')
        }
        else if( rputype == MISC_TYPE && (suffix < 7001 || suffix > 7999 )) {
            throw new Exception('Suffix must be betwwen 7001 and 7999 for miscellaneous property.')
        }
    }
    
    @ProxyMethod
    public void createPIN( faas ) {
        def validTxnTypes = ['ND','SD','CS','MC']
		if( faas.info.datacapture == true || validTxnTypes.contains( faas.info.txntype ) ) {
			def pin = [pin:faas.rpu.fullpin, claimno:faas.info.claimno, docstate:faas.docstate]
			em.sqlContext.createNamedExecutor('faas:insertPin').setParameters( pin ).execute()
		}
    }
	
	@ProxyMethod
    public void createOnlinePIN( faas ) {
        def pin = [pin:faas.rpu.fullpin, claimno:faas.info.claimno, docstate:faas.docstate]
		em.sqlContext.createNamedExecutor('faas:insertPin').setParameters( pin ).execute()
    }
    
    
    @ProxyMethod
    public void updateAutonumberTdNo( faas ) {
        faas.info.autonumber = TO_BOOLEAN( faas.info.autonumber )
        faas.info.autonumber = ( faas.info.datacapture == true ? false : faas.info.autonumber )
        
        if( faas.info.datacapture == true ||  faas.info.autonumber == false ) {
            return 
        }
        //TD Formatting Options:
        // Y - revision year
        // P - province index 
        // C - city index 
        // M - municipality index 
        // D - district index 
        // B - barangay index 
        def ry              = faas.rpu.ry +''
        def provindex       = faas.rp.provcityindex 
        def cityindex       = faas.rp.provcityindex 
        def muniindex       = faas.rp.munidistrictindex
        def districtindex   = faas.rp.munidistrictindex
        def barangayindex   = faas.rp.barangayindex
        
        def values = [Y:ry, P:provindex, C:cityindex, M:muniindex, D:districtindex, B:barangayindex]
        def tdno   = var.td_format 
        values.keySet().each {
            tdno = tdno.replace( it, values[it] )
        }
        tdno = tdno + '-' + seqSvc.getNextFormattedSeries( tdno )
        checkDuplicateTdNo( faas.objid, tdno )
        faas.info.tdno = tdno 
        em.update(faas.schemaname, faas )
        em.update(LISTSCHEMA_NAME, faas )
    }
	
	@ProxyMethod
	public List getClassificationList() {
		return em.sqlContext.createNamedQuery('faas:getClassificationList').resultList 
	}
    
	@ProxyMethod
	public def createFilter( filter ) {
		filter.objid = 'F' + new UID()
		def data = [:]
		data.putAll( filter )
		data.info = em.serializer.write( data.info )
		em.sqlContext.createNamedExecutor('faas:createFilter').setParameters( data ).execute()
		return filter 
	}
	
	@ProxyMethod
	public void removeFilter( filter ) {
		em.sqlContext.createNamedExecutor('faas:removeFilter').setParameter('objid', filter.objid).execute()
	}
    
    /*-----------------------------------------------------------------------
    ** Attachment Support 
    -----------------------------------------------------------------------*/
    @ProxyMethod 
    public def addAttachment( faasid, attachment ) {
		attachment.faasid   = faasid 
        attachment.docstate = 'UPLOADED' 
		attachment.absolutefilename = buildAbsoluteFileName(attachment )
        em.validate('faas:faasattachment', attachment )
        em.create('faas:faasattachment', attachment )
		return attachment 
    }
	
	@ProxyMethod 
    public def saveAttachment( attachment ) {
		attachment.absolutefilename = buildAbsoluteFileName(attachment )
        em.save('faas:faasattachment', attachment )
		return attachment 
    }
	
	
    def buildAbsoluteFileName( attachment ) {
		def filename = getUploadPath() 
		if( attachment.directory )
			filename += attachment.directory + '/' 
		filename += attachment.filename 
		return filename 
	}
	
	// return a "/" terminated path 
	def getUploadPath() {
		def upload_path = System.getProperty(UPLOAD_PATH)
		
		if( ! upload_path ) 
			throw new Exception('The upload_path property is not set in app.conf.')
        
		upload_path = upload_path.replaceAll('\\\\', '/')
		
		if( ! upload_path.endsWith('/') ) 
			upload_path += '/'
			
		return upload_path
	}
	
    @ProxyMethod
    public void removeAttachment( faasid, attachmentid )  {
        em.delete( 'faas:faasattachment', [objid:attachmentid] )
    }
    
    @ProxyMethod
    public List getAttachments( faasid ) {
        return em.sqlContext.createNamedQuery('faas:getAttachments').setParameter('faasid', faasid).resultList
    }
	
	@ProxyMethod
    public def getAttachmentById( objid ) {
        return em.sqlContext.createNamedQuery('faas:getAttachmentById').setParameter('objid', objid).singleResult
    }
    
	@ProxyMethod
	public def buildHtml( faasid ) {
		def attachments = getAttachments( faasid )
		if( ! attachments ) return '<html><body><h3>There are no associated attachments.</h3></body></html>'
		
		def html = '''<html>
				<head>
					<style type="text/css">
						body, td, th { 
							font-family: tahoma
							font-size  : 10pt
						}	
						td {
							background-color:white
						}
						th {
							background-color : #CCCCCC
						}
					</style>
				</head>
			<body>
		'''
		html += '<h2>List of Attachments</h2>'
		html += '<table width="80%">'
		
		def alist = partition(attachments, 4)
		alist.each{ list ->
			html += '<tr>'
			list.each{
				html += buildAttachmentHtml( it )
			}
			html += '</tr>'
		}
		html += '</table>'
		html += '</body></html>'
		return html 
	}
	
	def buildAttachmentHtml( attachment) {
		def html = ''
		def safefaasid = makeSafeFileName( attachment.faasid )
		def thumbfilename = buildThumbnailFileName( attachment )
		def imagepage = "http://${var.server_address}/downloads.war/faasattachment.jsp?faasid=${safefaasid}&resid=${thumbfilename}"
		def deleteicon = "http://${var.server_address}/downloads/images/delete.jpg"
		html += '<td>'
		html += '<table> '
		html += '<tr>'
		html += '<td><a href="displayAttachment?' + attachment.objid +'"><img src="' + imagepage + '"></img></a>' 
		html += '<td valign="top" width="25%">'
		html += '  <table>'
		html += '   <tr>'
		html += '      <td valign="top"><b>' + attachment.type + '</b></td>'
		html += '   </tr>'
		html += '   <tr>'
		html += '      <td>' + (attachment.remarks ? attachment.remarks :'') + '</td>'
		html += '   </tr>'
		html += ' </table>'
		html += '</td>'
		html += '</tr>'
		html += '<tr>'
		html += '      <td><a title="remove" href="removeAttachment?' + attachment.objid +'">Delete</a></td>' 
		html += '</tr>'
		html += '</table>'
		html += '</td>'
		return html 
	}
	
	def partition(array, size) {
		def partitions = []
		int partitionCount = array.size() / size

		partitionCount.times { partitionNumber ->
			def start = partitionNumber * size 
			def end = start + size - 1
			partitions << array[start..end]    
		}

		if (array.size() % size) partitions << array[partitionCount * size..-1]
		return partitions    
	}
    
	
	def getFileName(  filename ) {
		def fname = '' 
		def idx = filename.lastIndexOf( '.' )
		if( idx >= 0 ) {
			fname = filename.substring(0, idx)
		}
		return fname 
	}
	
	def getFileExtension(  filename ) {
		def ext = ''
		int idx = filename.lastIndexOf(".")
		if( idx >= 0 ) {
			ext = '.' + filename.substring(idx+1, filename.length())
		}
        return ext.toLowerCase()
	}

	def buildThumbnailFileName( attachment) {
		def ext = getFileExtension( attachment.filename )
		def targetname = getFileName( attachment.filename ) + '-thumb'
		if( ext ) targetname += ext 
		return targetname 
	}
	
	    
    def makeSafeFileName( strvalue ) {
        return strvalue.replaceAll('[\\W]', '')
    }
    
    /*-----------------------------------------------------------------------
    ** Support Methods
    -----------------------------------------------------------------------*/
    /* for land approval, update references of all land improvements to the new faas 
    *  applied only for the following if the transaction is not 
    *  datacapture 
    */
	@ProxyMethod 
    public void updateImprovementLandReference( faas ) {
        if( faas.info.datacapture == true ) return 
        if( faas.rpu.rputype != LAND_TYPE ) return 
        def prevfaasid = ( faas.previousfaases ? faas.previousfaases[0].faasid : null )
        def improvementIds = getLandImprovementIds( prevfaasid)
        improvementIds.each { 
            def improvementfaas = em.read( faas.schemaname, [objid:it.objid ] )
            improvementfaas.info.landfaasid          = faas.objid 
            improvementfaas.info.landfaastaxpayerid  = faas.info.taxpayerid 
            em.update( improvementfaas.schemaname, improvementfaas )
            
            // update faaslist landref
            def faaslist = [objid:it.objid, landfaasid:faas.objid, landfaastaxpayerid:faas.info.taxpayerid]
            em.sqlContext.createNamedExecutor('faas:updateListLandReference').setParameters(faaslist).execute()
        }
    }
    
    
    
    
    
    public void initOpenRpuInfo( rpu ) {
        if( rpu.rputype == LAND_TYPE ) {
            rpu.info.landdetails.each{ it.taxable = TO_BOOLEAN( it.taxable )}
			rpu.info.planttrees.each {
				it.bearing = it.bearing * 1.0 
				it.nonbearing = it.nonbearing * 1.0 
			}
			rpu.info.planttotal.bearing  = rpu.info.planttotal.bearing * 1.0 
			rpu.info.planttotal.nonbearing  = rpu.info.planttotal.nonbearing * 1.0 
			if( rpu.info.planttotal.adjustment == null )
				rpu.info.planttotal.adjustment = 0.00
        }
        else if( rpu.rputype == BLDG_TYPE ) {
            rpu.info.swornstatement = TO_BOOLEAN( rpu.info.swornstatement  )
            rpu.info.predominant  = TO_BOOLEAN( rpu.info.predominant  )
            rpu.info.condominium  = TO_BOOLEAN( rpu.info.condominium  )
            rpu.info.autocomputebldgdepreciation  = TO_BOOLEAN( rpu.info.autocomputebldgdepreciation  )
            rpu.info.depreciatecoreanditemseparately  = TO_BOOLEAN( rpu.info.depreciatecoreanditemseparately  )
        }
        else if( rpu.rputype == MACH_TYPE ) {
            //throw new Exception('FAASService.initOpenRpuInfo not yet implemented')
        }
        else if( rpu.rputype == PLANTTREE_TYPE ) {
            rpu.info.planttreedetails.each{
				it.bearing = it.bearing * 1.0 
				it.nonbearing = it.nonbearing * 1.0 
			}
			rpu.info.totalbearing = rpu.info.totalbearing * 1.0
			rpu.info.totalnonbearing = rpu.info.totalnonbearing * 1.0
        }
        else if( rpu.rputype == MISC_TYPE ) {
            rpu.info.miscrpuitems;
        }
        else {
            throw new Exception('RPU Type ' + rpu.rputype + ' is not supported.')
        }
    }
    
    
    void buildPinInfo( faas ) {
        def lgu = em.sqlContext.createNamedQuery('faas:getLgu').setParameter('objid', faas.rp.munidistrictid).singleResult
        if( !lgu) throw new Exception('Cannot load LGU for index ' + faas.rp.munidistrictid + '.' )
        def parentlgu = em.sqlContext.createNamedQuery('faas:getLgu').setParameter('objid', lgu.parentid).singleResult
        if( !parentlgu) throw new Exception('Cannot load Parent LGU for index ' + lgu.parentid  + '.' )
        
        faas.rp.provcity = parentlgu.lguname 
        faas.rp.provcityindex = parentlgu.indexno 
        faas.rp.munidistrict = lgu.lguname 
        faas.rp.munidistrictindex = lgu.indexno 
        faas.rp.pin = faas.rp.provcityindex + '-' + faas.rp.munidistrictindex + '-' + faas.rp.barangayindex + '-' + faas.rp.section + '-' + faas.rp.parcel 
        faas.rpu.fullpin = buildFullPin( faas )
    }
    
    String buildFullPin( faas ) {
        String fullpin = faas.rp.pin 
        if( faas.rpu.rputype != LAND_TYPE ) {
            fullpin += '-' + faas.rpu.suffix 
        }
        if( faas.rpu.rputype == BLDG_TYPE && faas.rpu.info.iscondo ) {
            fullpin += '-' + faas.rpu.info.subsuffix
        }
        return fullpin 
    }
    
    void validateRpu( faas ) {
        validateRY( faas )
        checkDuplicatePin( faas.info.txntype, faas.info.datacapture, faas.rpu.fullpin, faas.info.claimno  )
        validateSuffix( faas )
        if( faas.rpu.rputype != LAND_TYPE ) checkIfLandExist( faas )
    }
    
    void validateRY( faas ) {
        int ry = faas.rpu.ry 
        def query = 'faas:getRYSetting_' + faas.rpu.rputype // results to getRYSetting_land, etc
        def data = em.sqlContext.createNamedQuery(query).setParameter('ry', ry ).singleResult
        if( ! data ) throw new Exception('Revision Setting ' + faas.rpu.ry + ' does not exist.')
    }
    
    void checkDuplicatePin( txntype, datacapture, fullpin, claimno ) {
        def checktxntypes = 'ND/SD/CS/DC/MC'
        if( datacapture == false && checktxntypes.indexOf( txntype ) < 0 ) {
            return ;
        }
		//if section and parcel are both zero, then
		//property is unsurveyed, bypass pin checking 
		//check for patterns 000-00 or 00-000
        if( fullpin.indexOf('000-00') >= 0 || fullpin.indexOf('00-000') >= 0 ) {
			return 
		}
		
        //check for unique pin and claimno  only
        def data = em.sqlContext.createNamedQuery('faas:getPinClaimno').setParameters([pin:fullpin, claimno:claimno]).singleResult
        if( data ) throw new Exception('PIN ' + fullpin + ' already exists.')
    }
        
    void validateSuffix( faas ) {
        int suffix = faas.rpu.suffix 
        if( suffix == 0 ) return 
        if( suffix >= 1001 && suffix <= 1999 ) return 
        if( suffix >= 2001 && suffix <= 2999 ) return 
        if( suffix >= 3001 && suffix <= 6999 ) return 
        if( suffix >= 7001 && suffix <= 7999 ) return 
        throw new Exception('Invalid Suffix No. ' + suffix + '.')
    }
    
    void checkIfLandExist( faas ){
    	def faasland = em.sqlContext.createNamedQuery( 'faas:getLandReferenceByPin' ).setParameter( 'pin', faas.rp.pin ).singleResult;
    	if( !faasland ) throw new Exception( 'Land reference is required.' );
    }
    
    void resolveRpuType( faas ) {
        int suffix = faas.rpu.suffix 
        def rputype = null 
        if( suffix == 0 ) rputype = LAND_TYPE
        else if( suffix >= 1001 && suffix <= 1999 ) rputype = BLDG_TYPE
        else if( suffix >= 2001 && suffix <= 2999 ) rputype = MACH_TYPE
        else if( suffix >= 3001 && suffix <= 6999 ) rputype = PLANTTREE_TYPE
        else if( suffix >= 7001 && suffix <= 7999 ) rputype = MISC_TYPE
        else throw new Exception('Invalid Suffix No. ' + suffix + '.')
        faas.rpu.rputype = rputype
    }
    
    void updateLandRPInfo( faas ) {
    	def faasland = em.sqlContext.createNamedQuery( 'faas:getLandReferenceByPin' ).setParameter( 'pin', faas.rp.pin ).singleResult
		if( ! faasland ) throw new Exception('Land RPU reference does not exists. \nPlease verify that the record has already been created.')
        faasland = em.read( faasland.schemaname, faasland )
    	faas.info.landfaasid = faasland.objid
    	faas.info.landfaastaxpayerid = faasland.info.taxpayerid
    	faas.rp = faasland.rp
    }
    
	def getListByQuery( namedQuery, criteria, params, pagingkeys = null ) {
        if( ! params ) params = [ _start:0, _limit:25]
		def qry = em.sqlContext.createNamedQuery( namedQuery )
				    .setParameters( criteria )
				    .setFirstResult( params._start )
				    .setMaxResults( params._limit );
				  
		if( pagingkeys ) qry.setPagingKeys( pagingkeys );
		
		return qry.resultList
	}
	
	def faasExists( faasId ) {
		def data = em.sqlContext.createNamedQuery('faas:getState').setParameter('objid', faasId).singleResult
		if( data ) 
			return true
		return false
 	}
	
	def assignNewTdNo( faas ) {
		if( ! faas.tdNo ) return true
		if( faas.info.dataCapture && faas.info.dataCapture == false ) return true
		return false
	}
    
    def getCurrentRY() {
        def data = em.sqlContext.createNamedQuery('faas:getCurrentRY').singleResult 
        if( ! data ) return null 
        return data.ry 
    }
    
    
    
    def checkFaasTxnReference( faasid ) {
        def ref = em.sqlContext.createNamedQuery('faas:getTxnReference').setParameter('objid', faasid).singleResult
        if( ref ) {
            throw new Exception(ref.message)
        }
    }
    
    
    void insertTxnReference( faas ) {
        if( faas.previousfaases )  {
            //def prevfaas = faas.previousfaases[0]
			def pfaassize = faas.previousfaases.size 
			def prevfaas = ( pfaassize > 1 ? faas.previousfaases[pfaassize-1] : faas.previousfaases[0] )
            def msg = 'FAAS ' + prevfaas.tdno + ' is currently referenced by a ' + faas.info.txntype + ' transaction'
            if( faas.info.tdno ) {
                msg = 'FAAS ' + prevfaas.tdno + ' is currently referenced by FAAS ' + faas.info.tdno + '.' 
            }
            def ref = [
                objid       :   prevfaas.faasid,
                refid       :   faas.objid,
                refname     :   'FAAS',
                message     :   msg,
                txndate     :   faas.info.issuedate,
            ]
            em.sqlContext.createNamedExecutor('faas:insertTxnReference').setParameters( ref ).execute()
        }
    }
    
    void deletePin( faasinfo ) {
        em.sqlContext.createNamedExecutor('faas:deletePin').setParameter('pin', faasinfo.fullpin).execute()
    }
    
    void validateSubmit( faasinfo ) {
		if( faasinfo.docstate == FORAPPROVAL_STATE ) throw new Exception('FAAS has already been submitted.')
        if( faasinfo.docstate == FORPROVAPPROVAL_STATE ) throw new Exception('FAAS has already been submitted to province.')
        if( faasinfo.docstate == CURRENT_STATE) throw new Exception('FAAS is already current.')
        if( faasinfo.docstate == CANCELLED_STATE ) throw new Exception('FAAS has already been cancelled.')
        checkDuplicateTdNo( faasinfo.objid, faasinfo.tdno )
        validateTransactionInfo( faasinfo )
		
		if( 'GR/ND'.indexOf(faasinfo.txntype) == -1  && faasinfo.datacapture == false ) {
			checkLedgerBalanceByDate( faasinfo, faasinfo.issuedate )
		}
		
    }
    
    void validateSubmitToProvince( faasinfo ) {
        if( faasinfo.docstate == INTERIM_STATE ) throw new Exception('FAAS is still interim.')
        if( faasinfo.docstate == FORPROVAPPROVAL_STATE ) throw new Exception('FAAS has already been submitted to province.')
        if( faasinfo.docstate == CURRENT_STATE) throw new Exception('FAAS is already current.')
        if( faasinfo.docstate == CANCELLED_STATE ) throw new Exception('FAAS has already been cancelled.')
        checkDuplicateTdNo( faasinfo.objid, faasinfo.tdno )
        validateTransactionInfo( faasinfo )
    }
    
    void validateApprove( faasinfo ) {
        if( faasinfo.docstate == INTERIM_STATE ) throw new Exception('FAAS is still interim.')
        if( faasinfo.docstate == CURRENT_STATE) throw new Exception('FAAS is already current.')
        if( faasinfo.docstate == CANCELLED_STATE ) throw new Exception('FAAS has already been cancelled.')
        checkDuplicateTdNo( faasinfo.objid, faasinfo.tdno )
        checkCurrentLand( faasinfo )
        validateTransactionInfo( faasinfo )
    }
    
    void validateTransactionInfo( faasinfo ) {
        if( faasinfo.txntype == 'TR' || faasinfo.txntype == 'TRE' ) {
            if( faasinfo.prevtaxpayerid == faasinfo.taxpayerid ) {
                throw new Exception('Taxpayer should not be equal to previous taxpayer or owner.')
            }
        }
    }
    
    //validate rpu specific information here
    void validateRPUInfo( faas ) {
        if( faas.rpu.rputype == LAND_TYPE ) {
            //TODO:validate LandRPU 
            println 'TODO:FAASService.validateRPUInfo -> LAND not yet implemented.'
        }
    }
    
    void validateProvinceApproval( faasinfo ) {
        if( faasinfo.docstate == INTERIM_STATE ) throw new Exception('FAAS is still interim.')
        if( faasinfo.docstate == CURRENT_STATE) throw new Exception('FAAS is already current.')
        if( faasinfo.docstate == CANCELLED_STATE ) throw new Exception('FAAS has already been cancelled.')
        checkDuplicateTdNo( faasinfo.objid, faasinfo.tdno )
        checkCurrentLand( faasinfo )
    }
    
    void checkCurrentLand( faasinfo ) {
        // this validation is applied for land improvements.
        // approve improvements only when the land is current 
        if( faasinfo.rputype != 'land' ) {
            def landfaas = getFaasInfo( faasinfo.landfaasid )
            if( landfaas.docstate == CANCELLED_STATE ) throw new Exception('Land FAAS with TD No. ' + landfaas.tdno + ' has already been cancelled.')
            if( landfaas.docstate != CURRENT_STATE) throw new Exception('Land FAAS with TD No. ' + landfaas.tdno + ' is not yet current.\nApprove the land before approving this record.')
        }
    }
	
    Map updateFaasState( faas, state ) {
        faas.docstate = state
		em.update( faas.schemaname , faas )
		em.update( LISTSCHEMA_NAME, faas ) 
        // em.sqlContext.createNamedExecutor('faas:updateState').setParameters( faas ).execute()
        // em.sqlContext.createNamedExecutor('faas:updateListState').setParameters( faas ).execute()
        updatePinState( faas.rpu.fullpin, faas.info.claimno, faas.docstate )
        return faas 
    }
    
    void updatePinState( fullpin, claimno, docstate ) {
        def pincriteria = [pin:fullpin, claimno:claimno, docstate:docstate]
        if( claimno ) {
            em.sqlContext.createNamedExecutor('faas:updatePinStateWithClaimno').setParameters( pincriteria ).execute()
        }
        else {
            em.sqlContext.createNamedExecutor('faas:updatePinState').setParameters( pincriteria ).execute()
        }
    }
    
	@ProxyMethod 
    public void cancelPreviousFaas( faas ) {
        faas.previousfaases.each {
            def prevfaas = em.read( faas.schemaname, [objid:it.faasid])
            if( prevfaas ) {
                prevfaas.docstate           = CANCELLED_STATE 
                prevfaas.info.cancelreason  = faas.info.txntype 
                prevfaas.info.canceldate    = faas.info.issuedate 
                prevfaas.info.cancelledbytdnos = faas.info.tdno 
				prevfaas.info.cancelnote     = faas.cancelnote 
                em.update( prevfaas.schemaname, prevfaas )
                def previnfo = [objid:prevfaas.objid, docstate:CANCELLED_STATE, cancelreason:faas.info.txntype, canceldate:faas.info.issuedate, cancelledbytdnos:faas.info.tdno ]
                em.sqlContext.createNamedExecutor('faas:updateListCancelInfo').setParameters( previnfo  ).execute() 
            }
        }
    }
    
	@ProxyMethod 
    public void deleteTxnReference( faas ) {
        em.sqlContext.createNamedExecutor('faas:deleteTxnReference').setParameter('refid', faas.objid ).execute()
    }
    
    Map initTransfer( faas, txntype, prevtdno, autonumber ) {
        //
        //set transfer related info 
        def parseddate = dateSvc.parseCurrentDate()
        def txn = resolveTxnType( txntype ) 
        def currdate = dateSvc.format( 'yyyy-MM-dd', new Date()) 
        //
        //set previous info 
        faas.info.prevtdno      = faas.info.tdno 
        faas.info.prevpin       = faas.rpu.fullpin
        faas.info.prevtaxpayerid = faas.info.taxpayerid 
        faas.info.prevowner     = faas.info.ownername 
        faas.info.prevmv        = faas.rpu.totalmv
        faas.info.prevav        = faas.rpu.totalav 
        def prevfaas            = [ faasid:faas.objid, tdno:faas.info.tdno ]
        faas.previousfaases.add( prevfaas )
        //
        //set default values
        faas.objid              = 'F' + new UID()
        faas.docstate           = INTERIM_STATE
        faas.info.datacapture   = false 
        faas.info.txntype       = txn.txntype 
        faas.info.txn           = txn 
        faas.info.autonumber    = autonumber
        faas.info.issuedate     = currdate
        faas.info.effectivityyear = parseddate.year 
        faas.info.effectivityqtr  = 1 
        faas.info.dtappraised   = currdate 
        faas.info.dtrecommended = currdate 
        faas.info.dtapproved    = currdate 
        faas.info.titletype     = 'TCT'
        //
        //clear info 
        faas.info.tdno          = null 
        faas.info.ownername     = null 
        faas.info.owneraddress  = null
        faas.info.taxpayerid    = null
        faas.info.taxpayername  = null
        faas.info.taxpayeraddress      = null 
        faas.info.administratorid      = null 
        faas.info.administratorname    = null 
        faas.info.administratoraddress = null 
        faas.info.memoranda            = null 
        faas.info.titleno              = null
        faas.info.titledate            = null 
		faas.lgutype 					= var.lgu_type
        return faas 
    }
    
	@ProxyMethod
	public List getBarangayIdList() {
		def brgylist = em.sqlContext.createNamedQuery('faas:getBarangays').resultList
		brgylist.sort{ it.name }
		return brgylist 
	}
	
	@ProxyMethod
	public List getFaasIdForRevision( newry ) {
		return em.sqlContext.createNamedQuery('faas:getFAASIdForRevision')
				.setParameters([ newry:newry  ])
				.resultList
				.objid 
	} 
	 
	
	@ProxyMethod 
	public void validateBatchRY( newry ) {
		def rptsetting = em.sqlContext.createNamedQuery('faas:getCurrentRY').singleResult 
		if( !rptsetting ) {
			throw new Exception('RPT Setting is not defined.')
		}
		if( rptsetting.ry >= newry ) {
			throw new Exception('New Revision Year must be greater than current revision year ' + rptsetting.ry )
		}
		
		//check landry setting 
		def ry = em.sqlContext.createNamedQuery('faas:getRYSetting_land')
						.setParameter('ry', newry)
						.singleResult 
		if( ! ry ) throw new Exception( "Land Revision Year Setting for $newry is not defined.")
		
		//check bldgry setting 
		ry = em.sqlContext.createNamedQuery('faas:getRYSetting_bldg')
						.setParameter('ry', newry)
						.singleResult 
		if( ! ry ) throw new Exception( "Building Revision Year Setting for $newry is not defined.")
		
		//check machry setting 
		ry = em.sqlContext.createNamedQuery('faas:getRYSetting_mach')
						.setParameter('ry', newry)
						.singleResult 
		if( ! ry ) throw new Exception( "Machine Revision Year Setting for $newry is not defined.")
		
		//check planttreery setting 
		ry = em.sqlContext.createNamedQuery('faas:getRYSetting_planttree')
						.setParameter('ry', newry)
						.singleResult 
		if( ! ry ) throw new Exception( "Plant/Tree Revision Year Setting for $newry is not defined.")
		
		//check getRYSetting_misc setting 
		ry = em.sqlContext.createNamedQuery('faas:getRYSetting_misc')
						.setParameter('ry', newry)
						.singleResult 
		if( ! ry ) throw new Exception( "Miscellaneous Revision Year Setting for $newry is not defined.")
	}
	
	
	def getRySetting( rputype, newry ) {
		if( rputype == 'land' ) {
			return em.sqlContext.createNamedQuery('faas:getRYSetting_land')
						.setParameter('ry', newry)
						.singleResult 
		}
		
		if( rputype == 'bldg' ) {
			return em.sqlContext.createNamedQuery('faas:getRYSetting_bldg')
						.setParameter('ry', newry)
						.singleResult 
		}
		
		if( rputype == 'mach' ) {
			return em.sqlContext.createNamedQuery('faas:getRYSetting_mach')
						.setParameter('ry', newry)
						.singleResult 
		}
		
		if( rputype == 'planttree' ) {
			return em.sqlContext.createNamedQuery('faas:getRYSetting_planttree')
						.setParameter('ry', newry)
						.singleResult 
		}
		
		if( rputype == 'misc' ) {
			return em.sqlContext.createNamedQuery('faas:getRYSetting_misc')
						.setParameter('ry', newry)
						.singleResult 
		}
		return null 
	}
	
	@ProxyMethod
	public void  reviseFaas( faasidlist, newry ) {
		faasidlist.each{ faasid -> 
			def faas = em.read( SCHEMA_NAME, [objid:faasid] )
			if( ! faas ) {
				def msg = 'Cannot open FAAS ' + faasid 
				println msg 
				return msg  
			}

			def prevtdno     = faas.info.tdno
			def newrysetting = getRySetting( faas.rpu.rputype, newry ) 
			def autonumber 	 = TO_BOOLEAN( var.td_autonumber )
				
			def msg = null 
			try {
				faas = initGeneralRevision( faas, 'GR', prevtdno, autonumber, newrysetting )
				faas.info.memoranda	= 'REVISED PURSUANT TO R.A. 7160' 
				faas.info.annotated = TO_BOOLEAN( faas.info.annotated )
				faas = create( faas )
				logSvc.log('REVISED','Faas', faasid)
				msg = 'Successfully revised -> ' + prevtdno 
				println msg 
			}
			catch ( e ) {
				msg = 'Error revising -> ' + prevtdno + '. [Error] ' + e.message 
				println msg
			}
		}
	}		
	
	
	
	Map initGeneralRevision( faas, txntype, prevtdno, autonumber, newrysetting ) {
		if( !newrysetting ) {
			throw new Exception('New RY Setting is required.')
		}
		
		faas = initReassessment( faas, txntype, prevtdno, autonumber )
		if( faas.rpu.ry >= newrysetting.ry ) {
			throw new Exception('New Revision Year must be greater than ' + faas.rpu.ry + '.' )
		}
		
		
		//reset txntype to GR 
		def txn 			= resolveTxnType( txntype )
		faas.info.txntype	= txn.txntype 
        faas.info.txn       = txn 
		faas.rpu.ry			= newrysetting.ry 
		
		//recalculate due to gr 
		def rputype = faas.rpu.rputype 
		
		if( 'land'.equals( rputype )  ) {
			faas = landRpuSvc.initGeneralRevision( faas, newrysetting )
		}
		else if( 'bldg'.equals( rputype )  ) {
			faas = bldgRpuSvc.initGeneralRevision( faas, newrysetting )
		}
		else if( 'mach'.equals( rputype )  ) {
			faas = machRpuSvc.initGeneralRevision( faas, newrysetting )
		}
		else if( 'planttree'.equals( rputype )  ) {
			faas = planttreeRpuSvc.initGeneralRevision( faas, newrysetting )
		}
		else if( 'misc'.equals( rputype )  ) {
			faas = miscRpuSvc.initGeneralRevision( faas, newrysetting )
		}
		else {
			throw new Exception( 'Cannot process rpu type ' + rputype + '.' )
		}
		return faas 
		
	}
	
    Map initReassessment( faas, txntype, prevtdno, autonumber ) {
        //
        //set reassessment related info 
        def parseddate = dateSvc.parseCurrentDate()
        def txn = resolveTxnType( txntype ) 
        def currdate = dateSvc.format( 'yyyy-MM-dd', new Date()) 
        //
        //set previous info 
		if( txntype != 'MC' ) {
			faas.info.prevtdno      = faas.info.tdno 
			faas.info.prevpin       = faas.rpu.fullpin
			faas.info.prevtaxpayerid = faas.info.taxpayerid 
			faas.info.prevowner     = faas.info.ownername 
			faas.info.prevmv        = faas.rpu.totalmv
			faas.info.prevav        = faas.rpu.totalav 
			def prevfaas            = [ faasid:faas.objid, tdno:faas.info.tdno ]
			faas.previousfaases.clear()
			faas.previousfaases.add( prevfaas )
		}
        //
        //set default values
        faas.objid              = 'F' + new UID()
        faas.docstate           = INTERIM_STATE
        faas.info.datacapture   = false 
        faas.info.txntype       = txn.txntype 
        faas.info.txn           = txn 
        faas.info.autonumber    = autonumber
        faas.info.issuedate     = currdate
        faas.info.effectivityyear = parseddate.year + 1
        faas.info.effectivityqtr  = 1 
        faas.info.dtappraised   = currdate 
        faas.info.dtrecommended = currdate 
        faas.info.dtapproved    = currdate 
		faas.lgutype 			= var.lgu_type
        //
        //clear info 
        faas.info.tdno          = null 
        faas.info.memoranda     = null 
        return faas 
    }
	
	Map initMultipleClaim( faas, txntype, prevtdno, autonumber ) {
        //
        //set reassessment related info 
        def parseddate = dateSvc.parseCurrentDate()
        def txn = resolveTxnType( txntype ) 
        def currdate = dateSvc.format( 'yyyy-MM-dd', new Date()) 
        //
        //set default values
        faas.objid              = 'F' + new UID()
        faas.docstate           = INTERIM_STATE
        faas.info.datacapture   = false 
        faas.info.txntype       = txn.txntype 
        faas.info.txn           = txn 
        faas.info.autonumber    = autonumber
        faas.info.issuedate     = currdate
        faas.info.effectivityyear = parseddate.year + 1
        faas.info.effectivityqtr  = 1 
        faas.info.dtappraised   = currdate 
        faas.info.dtrecommended = currdate 
        faas.info.dtapproved    = currdate 
		faas.lgutype 			= var.lgu_type
        //
        //clear info 
        faas.info.tdno          = null 
        faas.info.memoranda     = null 
        return faas 
    }
    
    void updateMessage( faas, message ) {
        faas.message = message
        def params = [objid:faas.objid, message:message]
        em.sqlContext.createNamedExecutor('faas:updateMessage').setParameters( params ).execute() 
    }
	
	void insertForTransmittal( faas ) {
		def fortransmittal = [
			objid 		: faas.objid,
			module		: 'rpt',
			dtposted	: dateSvc.serverDate, 
			doctype		: 'faas',
			docno		: ( faas.info.tdno != null ? faas.info.tdno : faas.rpu.fullpin ),  
			postedbyid	: env.USERID,
			postedby	: env.USERFORMALNAME,
			postedbytitle : env.JOBTITLE,
		]
		forTransmittalSvc.create( fortransmittal )
	}
	
	void sendRemoteMessage( faas, action, data ) {
		def receiverid = faas.rp.provcityindex + '-' + faas.rp.munidistrictindex
		def receivername = faas.rp.munidistrict
		
		def msg = msgSvc.createMessage( action, data )
		msg.receiverid = receiverid 
		msg.receivername = receivername 
		msgSvc.send( msg )   
    }
    
    void sendToOutbox( faas ) {	
		def remote_connection_active = var.remote_connection_active
		if( !remote_connection_active ) remote_connection_active = 0
		
		def remote_connection_debug = var.remote_connection_debug
		if( ! remote_connection_debug ) remote_connection_debug = 0
		
		if( (faas.info.datacapture == false || TO_BOOLEAN(remote_connection_debug) == true ) && TO_BOOLEAN(remote_connection_active) == true) {
			def attachments = getAttachments( faas.objid)
			def attachment = [ 
				faas		: faas, 
				attachments	: attachments,
				entity		: entitySvc.open( faas.info.taxpayerid, null  ),
			]
			def msg = msgSvc.createMessage( 'faas.receive', attachment )
			msg.refid = faas.objid 
			msgSvc.send( msg ) 
		}
    }
	
	void updateFaasListState( faasid, docstate) {
        def params = [ objid:faasid, docstate:docstate ]
        em.sqlContext.createNamedExecutor('faas:updateListState').setParameters( params ).execute()
    }
    
    void moveOutboxMessageToProcessed( refid ) {
		//msgSvc.processOutboxMessage( refid )
    }
    
    void updateAttachmentStates( faas, docstate ) { 
        em.sqlContext.createNamedExecutor('faas:updateAttachmentState').setParameters([faasid:faas.objid, docstate:docstate]).execute()
    }
	
	@ProxyMethod  
	public void updateAttachmentState( attachment, docstate  ) {
        attachment.docstate = docstate 
		em.update( 'faas:faasattachment', attachment )
    }
	
	boolean TO_BOOLEAN( value ) {
		if( value instanceof Boolean ) return value 
		return '1/y/yes/true/t'.indexOf( value.toString().toLowerCase() ) >= 0
	}
	
	def getNextAutonumberTdNo( faas ) {
        if( faas.info.datacapture == true ||  faas.info.autonumber == false ) {
            return faas.info.tdno 
        }
        //TD Formatting Options:
        // Y - revision year
        // P - province index 
        // C - city index 
        // M - municipality index 
        // D - district index 
        // B - barangay index 
        def ry              = faas.rpu.ry +''
        def provindex       = faas.rp.provcityindex 
        def cityindex       = faas.rp.provcityindex 
        def muniindex       = faas.rp.munidistrictindex
        def districtindex   = faas.rp.munidistrictindex
        def barangayindex   = faas.rp.barangayindex
        
        def values = [Y:ry, P:provindex, C:cityindex, M:muniindex, D:districtindex, B:barangayindex]
        def tdno   = var.td_format 
        values.keySet().each {
            tdno = tdno.replace( it, values[it] )
        }
		
		def seqno = seqSvc.getNextFormattedSeries( tdno )
        if( var.td_format.contains( '-') ) {
            return  tdno + '-' + seqno 
        }
        return  tdno + seqno
    }
	
}

