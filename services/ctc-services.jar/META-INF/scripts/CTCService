import com.rameses.annotations.*;
import com.rameses.common.*;
import com.rameses.rules.common.*
import java.math.BigDecimal
import java.math.RoundingMode


public class CTCService 
{
	@Resource('RuleService/local')
	def ruleSvc
	
	@Service('DateService')
	def dateSvc
	
	@PersistenceContext("main")
	def em
	
	
	@ProxyMethod
	public def calculate( entity ) {
		def result = executeRule( entity )
		def assessment = [:]
		assessment.tax = createTaxItems( result )
		assessment.items = result.values() as List
		assessment.total = assessment.items*.amount.sum()
		if( assessment.total==null ) assessment.total = 0.00
		initItems( assessment )		
		return assessment
	}
	
	@ProxyMethod
	public def buildCaptureItems( entity ) {
		def result = executeRule( entity )
		if( result.business ) result.business.amount = entity.tax.business
		if( result.basic )    result.basic.amount = entity.tax.basic
		if( result.salary )   result.salary.amount = entity.tax.salary
		if( result.property ) result.property.amount = entity.tax.property
		if( result.interest ) result.interest.amount = entity.tax.interest
		entity.items = result.values() as List
		initItems( entity )
		return entity
	}
	
	
	def executeRule( entity ) {
		def facts = []
		facts << createCTCFact( entity )
		if( entity.doctype == 'CTCI' )
			facts << createIndividualFact( entity )
		else if( entity.doctype == 'CTCC' )
			facts << createCorporateFact( entity )
			
		def result = [:]
		def ruleAction = ruleSvc.createRuleAction()
		ruleAction.addCommand( 'compute', new ComputationHandler( result: result ) )		
			
		ruleSvc.execute( 'ctcassessment', facts, [ruleActionHandler:ruleAction], 'TAX' )
		updateCTCFact( facts[0], result )
		ruleSvc.execute( 'ctcassessment', facts, [ruleActionHandler:ruleAction], 'INTEREST' )
		return result;
	}
	
	def createTaxItems( result ) {
		def values = [
			business: 0.00,
			basic:    0.00,
			salary:   0.00,
			property: 0.00,
			interest: 0.00,
		]
		result.each{k,v-> values[k] = v.amount }
		
		return values
	}
	
	void initItems( assessment ) {
		assessment.items = assessment.items.groupBy { it.acctid }.collect {
			def v = it.value.remove(0)
			it.value.each { v.amount += it.amount }
			return v
		}
		
		assessment.items.each {
			def acct = em.read("incomeacct:incomeacct", [objid: it.acctid])
			it.accttitle = acct.accttitle
			it.acctno    = acct.acctno
			it.systype   = acct.systype
			it.fundid	 = acct.fundid
			it.fundname	 = acct.fundname
		}
	}
	
	void updateCTCFact( fact, result ) {
		def taxes = createTaxItems( result );
		fact.basictax   = taxes.basic
		fact.salarytax	= taxes.salary
		fact.businessgrosstax = taxes.business
		fact.propertyincometax  = taxes.property
		fact.additionaltax      = taxes.additionaltax
		fact.amtdue		= taxes.business + taxes.basic + taxes.salary + taxes.property
	}
	
	def createIndividualFact( entity ) {
		def fact = ruleSvc.createFact('ctcassessment','ctc.assessment.facts.IndividualFact')
		
		def payer = entity.info.payer;
		fact.profession = payer.info.profession
		fact.citizenship = payer.info.citizenship
		fact.gender = payer.info.gender
		fact.civilstatus = payer.info.civilstatus
		fact.seniorcitizen = payer.info.seniorcitizen ? true : false
		fact.annualsalary = entity.annualsalary
		fact.businessgross = entity.businessgross
		fact.propertyincome = entity.propertyincome
		
		return fact
	}
	
	def createCorporateFact( entity ) {
		def fact = ruleSvc.createFact('ctcassessment','ctc.assessment.facts.CorporateFact')

		fact.orgtype = entity.info.payer.info.orgtype
		fact.realpropertyav = entity.realpropertyav
		fact.businessgross = entity.businessgross
		
		return fact
	}
	
	def createCTCFact( entity ) {
		def fact = ruleSvc.createFact('ctcassessment','ctc.assessment.facts.CTCFact')

		fact.barangayid = entity.barangayid
		
		def currentDate = entity.info.txndate ? dateSvc.parseDate(entity.info.txndate, null) : dateSvc.parseCurrentDate()
		fact.year       = currentDate.year 
		fact.qtr        = currentDate.qtr 
		fact.month      = currentDate.month 
		fact.day        = currentDate.day 
		fact.additional = entity.additional ? true : false
		fact.basictax   = 0.00
		fact.salarytax	= 0.00
		fact.businessgrosstax   = 0.00
		fact.propertyincometax  = 0.00
		fact.additionaltax      = 0.00
		fact.amtdue		= 0.00
		
		return fact
	}
	
}


class ComputationHandler implements RuleActionHandler 
{
	def result
	
	def util = new Util()
	
	public void execute( drools, data) {	
		compute( data )
	}
	
	void compute( data ) {
		def amount = util.round( util.evaluate( data.expr, data.vars ) )
		
		result[data.type] = [
			acctid:    data.acctid,
			acctno:    data.acctno,
			accttitle: data.accttitle,
			amount:    amount,
		];
	}
	
	def eval( data ) {
		
	}
}


class Util {

   int DEFAULT_SCALE = 2
	
	public def evaluate( expr, params ) {
		def fn = '''
            def IIF( cond, trueval, falseval ) {
                return ( cond ? trueval : falseval )
            }
        '''
		
		return (new GroovyShell( new Binding( params) )).evaluate( fn + expr )
	}
    
    public def round( amount ) {
		def bd = new BigDecimal(amount+'')
        return bd.setScale(DEFAULT_SCALE, RoundingMode.HALF_UP)
    }

}
